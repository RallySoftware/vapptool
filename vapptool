#!/usr/bin/env python -B

from optparse import OptionParser
import libxml2, os, subprocess, sys

GET_GUESTINFO = ['/usr/sbin/vmware-rpctool', '"info-get guestinfo.ovfEnv"']

def load_ovf():
    pobj = subprocess.Popen(' '.join(GET_GUESTINFO),
                            bufsize=1,
                            shell=True,
                            stdout=subprocess.PIPE,
                            stderr=subprocess.STDOUT)
    buf = pobj.stdout.read()
    ret = pobj.wait()
    if ret or not buf or buf.startswith('No value found'):
        raise Exception('No value found: guestinfo.ovfEnv')
    return buf

def load_hosts():
    return file('/etc/hosts', 'r').read()

def ovf_xpath(path):
    '''
    Given an xpath string, return the node set evaluated by the xpath.

    @returns: A node set.
    @raises: xpathError - If xpath cannot be evaluated
    '''
    nsdict = {
      'default': "http://schemas.dmtf.org/ovf/environment/1",
      'xsi':"http://www.w3.org/2001/XMLSchema-instance",
      'oe':"http://schemas.dmtf.org/ovf/environment/1",
      've':"http://www.vmware.com/schema/ovfenv" }

    xml = load_ovf()
    doc = libxml2.parseDoc(xml)

    context = doc.xpathNewContext()

    for k, v in nsdict.iteritems():
        context.xpathRegisterNs(k, v)

    return context.xpathEval(path)

def ovf_property(key):
    '''
    Given a key for a vApp property, return the value for that key.

    @returns: A string value, or None.
    @raises: Exeption - If multiple properties are found for the given key.
    '''
    nodes = ovf_xpath("/default:Environment/default:PropertySection/default:Property[@oe:key='%s']/@oe:value" %(key))
    if not nodes:
        return None
    elif len(nodes) > 1:
        raise Exception('Multiple nodes found, expected only one.')

    return nodes[0].get_content()

def ovf_ip_address():
    vm_name = ovf_property('vm_name')

    if vm_name:
        ip_address = ovf_property("ip_address_%s" %(vm_name))
        if ip_address:
            return ip_address

    raise Exception('guestinfo.ovfEnv is present, but does not contain a vApp ip_address property for this VM')


def cmd_inspect():
    if ovf_property('vm_name'):
        return [ 0, None, None ]

    return [ 1, None, 'guestinfo.ovfEnv is present, but does not contain expected vApp properties' ]


def cmd_printovf():
    return [ 0, load_ovf(), None ]


def cmd_localhost():
    ip_address = ovf_ip_address()
    if ip_address:
        return [ 0, ip_address, None ]

    return [ 1, None, 'guestinfo.ovfEnv is present, but does not contain a vApp ip_address_ property for this VM' ]


def cmd_property(key):
    value = ovf_property(key)
    if value:
        return [ 0, value, None ]

    return [ 1, None, "guestinfo.ovfEnv is present, but does not contain a vApp %s property for this VM" %(key) ]


def cmd_hosts():
    autogen = "auto-generated by Rally - do not modify"

    etc_hosts = ""
    for line in load_hosts().split('\n'):
        if autogen not in line:
            if line != "":
                etc_hosts += line + '\n'

    dns_search_domain = ovf_property('dns_search_domain')
    ip_address = ovf_ip_address()

    etc_hosts += "%s vapp_localhost vapp_localhost.%s #%s\n" %(ip_address, dns_search_domain, autogen)

    vapp_hosts = ovf_xpath('//default:PropertySection/default:Property[@oe:key="vm_name"]/@oe:value')

    for vapp_host in vapp_hosts:
        vapp_host_name = vapp_host.get_content()
        vapp_host_ip = ovf_property("ip_address_" + vapp_host_name)
        etc_hosts += "%s vapp_%s vapp_%s.%s #%s\n" %(vapp_host_ip, vapp_host_name, vapp_host_name, dns_search_domain, autogen)

    return [ 0, etc_hosts, None ]


def cmd_resolv():
    dns_search_domain = ovf_property('dns_search_domain')
    dns1 = ovf_property('dns1')
    dns2 = ovf_property('dns2')

    if dns_search_domain and dns1 and dns2:
        resolv  = '# Auto-generated by Rally vapptool\n'
        resolv += "domain %s\n" %(dns_search_domain)
        resolv += "nameserver %s\n" %(dns1)
        resolv += "nameserver %s\n" %(dns2)

        return [ 0, resolv, None ]

    return [ 1, None, "guestinfo.ovfEnv is present, but does not contain vApp properties for dns_search_domain, dns1, and/or dns2" ]

def main():
    cmdline=sys.argv[1:]
    cmdline_parser = OptionParser()

    # TODO: commands yet to complete
    #     --sysconfig-network
    #     --iface

    cmdline_parser.add_option('-i', '--inspect',   dest='inspect',   action="store_true", default=False, help='Exits 0 when executed from on a VM within Rally vApp, otherwise non-zero')
    cmdline_parser.add_option('-P', '--print',     dest='printovf',  action="store_true", default=False, help='Prints the value of guestinfo.ovfEnv')
    cmdline_parser.add_option('-l', '--localhost', dest='localhost', action="store_true", default=False, help='Prints the value of the ip_address property for this VM')
    cmdline_parser.add_option('-p', '--property',  dest='property',  action="store",                     help='Prints the value of the property for this VM')
    cmdline_parser.add_option('-H', '--hosts',     dest='hosts',     action="store_true", default=False, help='Prints output suitable for /etc/hosts that contains entries for all VMs in this vApp')
    cmdline_parser.add_option('-r', '--resolv',    dest='resolv',    action="store_true", default=False, help='Prints output suitable for /etc/resolv.conf that contains entries for dns_search_domain, dns1, and dns2')

    # parse the command line options
    (options, args) = cmdline_parser.parse_args(cmdline)

    try:
        if options.inspect:
            # invoke inspect function to determine if we are in a vApp.
            cmd_result = cmd_inspect()

        elif options.printovf:
            cmd_result = cmd_printovf()

        elif options.localhost:
            cmd_result = cmd_localhost()

        elif options.property:
            cmd_result = cmd_property(options.property)

        elif options.hosts:
            cmd_result = cmd_hosts()

        elif options.resolv:
            cmd_result = cmd_resolv()

        else:
            cmdline_parser.print_help()
            sys.exit(1)


        if cmd_result[1]:
            print(str(cmd_result[1]))

        if cmd_result[2]:
            print >> sys.stderr, str(cmd_result[2])

        sys.exit(cmd_result[0])

    except Exception, e:
        print >> sys.stderr, str(e)
        sys.exit(1)

    sys.exit(1)

if __name__ == "__main__":
    main()
